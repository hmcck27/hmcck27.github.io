---

title: JAVA와 JVM
categories: [Java]
tags: [Java, JVM, JRE, JDK]     # TAG names should always be lowercase
author:
name: Choi Jin Kyu
link: https://github.com/hmcck27
toc: true
# date: 2022-02-05

img_path: /assets/img/mdImage/

---

# JAVA와 JVM

Java로 개발하는 사람들은 기본적으로 java의 작동원리에 대해서는 알고 있어야 한다고 생각한다.  
학교 전공 수업에서 컴파일, 기계어 이런 용어들은 많이 들어봤을 것이다.  

java도 마찬가지다 결국에는 기계어로 번역되고 해당 기계어가 실행이 된다.  

하지만 java는 중간에 jvm이라는 가상 환경이 필요하다.  

왜 가상환경이 필요한건지 의문이 생길 수 있다.  

그런거에 대해서 한번 정리해보자.

---

## JRE와 JDK

우리가 자바로 개발하다보면, JRE 또는 JDK를 설치하게 된다.  
뭐.. 프로그래밍 언어마다 설치해주는게 있을 수 있지~ 라고 생각할 수 있지만  

뭐 자바를 실행시키기 위해서 ide를 켰더니 jdk가 필요하다고 하고,  
또 tomcat을 실행시키려고 보니까 jre가 필요하다고 하고,  
뭔가 java 컴파일러랑 jvm같은 것들을 묶어서 jre, jdk라고 하는 것 같은데  

이번에 정확하게 정리해보자.  

일단 둘의 차이점 먼저 알아보자.  

JRE = Java Runtime Environment
JDK = Java Development Kit  

JRE는 java 프로그램이 실행되는 환경을 의미한다.  
당연히 JVM + 라이브러리 + java api를 포함한다.  
javac 같은 경우는 jre에는 포함되지 않는다.   

JDK는 java를 개발하기 위해서 필요한 kit이다.  
개발단계니까, JRE에다가 java compiler도 추가되어 있다.  

---

## JVM의 필요성

JVM은 java만의 특징이라고 생각한다.  
결국 java가 실행되기 위한 환경을 의미하는데,  
중요한 점은 virtual machine이 os위에서 돌아간다는 점이다.  

일단 왜 가상 머신이 돌아가는 걸까 ?  

jvm은 java virtual machine의 약자이다.  
os는 직접 java 프로그램을 실행하지 않는다.  

java compiler가 소스 프로그램으로부터 바이트 코드를 만들고,  
해당 바이트 코드를 기계어로 번역해야 하는데,  
이때 jvm이 바이트 코드를 기계어로 번역한다.  

즉 바이트 코드를 이해하고 기계어로 번역해서 os가 실행할 수 있게 해준다.  

jvm이 필요한 이유는 뭘까 ?  
바로 os마다 환경이 다 다르기 때문이다.  
os별로 다른 java program을 개발할 수는 없으니까,  
os에 종속되지 않고 개발하고 os위에 jvm이 os가 잘 실행할 수 있도록 번역하게 한다.  

즉 잘 생각해보면 jvm 자체는 os에 종속적이다.  

java 프로그램을 작성하고 javac가 컴파일하면 .class 파일이 만들어진다.  
이게 바이트 코드이다.  

실제로 tomcat으로 자바 프로그램을 실행해보면,  
실행 폴더 내부에는 .class 파일만 존재한다.  

톰캣은 jre의 jvm을 갖고 있고  
jvm이 해당 파일들을 기계어로 번역해서 os가 실행할 수 있도록 해주는 것이다.  

이 바이트 코드는 일반적인 os에서는 실행할 수 없다.  
jvm이 중간에 실행하기 때문에 java의 가장 큰 장점인 다른 플랫폼에게서의 독립성을 보장해준다.  

---

## JVM의 작동 원리

jvm이 왜 필요한지 왜 중요한지 알았으니  
구체적으로 jvm이 어떤 방식으로 작동되는지 알아보자.  

자바 개발자들이 소스를 작성하고 해당 소스는 javac에 의해서 .class를 생성하게 된다.  

이건 아직 os가 읽을 수 없는 반기계어이다.  

바이트 코드는 다음과 같은 절차를 따른다.  
1. class loader에 의해서 JVM내로 로드 된다.
2. 실행 엔진에 의해서 기계어로 번역되고 메모리상의 Runtime Data Area에 배치된다.  
여기서 실행 엔진에는 두가지가 있다. -> interpreter와 Just in time compiler
interpreter는 바이트 코드를 한줄씩 읽기 때문에 실행 속도 느리지만 JIT compiler는 적절한 시점에 바이트 코드 전체를 컴파일하고 직접 실행한다.
즉 interpreter로 실행하다가 중간에 전체 컴파일해서 실행한다는 것이다.  

## Class Loader
java는 동적으로 객체들을 로드한다.  
즉 컴파일 타임이 아니라 런타임에 클래스를 처음 참조할때, 해당 클래스를 로드하고 링크하는 특징이 있다.  
이 동적 로드를 담당하는 부분이 JVM의 class loader이다.  

1. 계층 구조
클래스 로더도 여러가지 있고, 이 로더들은 계층구조로 존재한다.
2. 위임 모델
클래스를 로드할때 먼저 상위 클래스 로더를 확인하고 상위 클래스 로더에 클래스가 존재한다면 상위 클래스 로더를 사용하고 없으면 직접 로드한다. 즉 언제나 상위 클래스 로더를 확인하고 있으면 위임한다.
3. 가시성 제한
하위 클래스 로더는 상위 클래스 로더를 볼 수 있지만, 상위 클래스 로더는 하위 클래스 로더를 확인할 수 없다.
4. 언로드 불가
클래스 로더는 로더만 가능하고 언로드는 불가능하다.

## Runtime Data Area
1. pc register
program counter 레지스터는 각 스레드마다 존재한다.  
스레드가 실행될때 생성된다.   
pc register는 현재 수행중인 jvm 명령의 주소를 갖는다. -> 즉 어떤 명령을 수행하고 있는지 알고 있다. 
2. jvm stack
스레드마다 하나씩 갖고 있으며 스레드가 생성될때 생성된다. stack frame이라는 구조체를 저장한다.  
즉 데이터 저장의 단위가 이 구조체이다.  
스택이니까 당연히 pop, push의 연산만 한다.  
이 stack frame은 메소드가 수행될때마다 생성되고 해당 스레드의 stack frame에 쌓인다.  
우리가 에러가 발생했을때, e.printstacktrace()가 해당 스레드의 jvm stack에 있는 stack frame들을 하나씩 꺼내서 출력하는 것이다.  
stack frame에는 지역 변수 배열, 피연산자 스택, 실행중인 메소드가 속한 클래스의 런타임 상수 풀에 대한 레퍼런스를 갖는다.  
이들은 컴파일 시점에 이미 결정되기 때문에 컴파일 타임에 stack의 크기가 결정된다.
3. native method stack
자바 외의 프로그래밍 언어로 작성된 네이티브 코드를 위한 스택이다.
4. heap
인스턴스, 객체를 저장하는 공간이고 GC의 대상이다. 
5. method
모든 스레드가 공유하는 공간이다. jvm이 시작될때 생성된다.  
jvm이 읽은 클래스들과 인터페이스에 대한 런타임 상수 풀, 필드와 메소드 정보, static 변수, 메소드의 바이트 코드를 저장한다. 
6. runtime constant pool
메소드 영역에 포함되고, 각 클래스와 인터페이스의 상수, 메소드와 필드에 대한 모든 레퍼런스를 담고 있다. 

## Garbage Collection
C로 프로그래밍을 하다보면, malloc같은 동적 할당을 통해서 배열이나 변수의 메모리 공간을 할당해준다.  
이때 우리는 꼭 잊지 않고 사용하고 남은 공간들의 할당을 해제해줘야 한다.  

java의 경우는 기본적으로 heap영역에 대해서 Garbage Collection 기능을 제공한다.  
즉 heap영역의 사용하지 않는 메모리 공간에 대해서는 자동으로 할당을 해제한다.  

heap의 경우는 new Object()와 같이 새롭게 생성하는 객체들이 저장되기 때문에  
우리는 따로 메모리 해제를 안해줘도 된다.  

하지만 static이나 final 변수들이 저장되는 method영역은 GC의 대상이 아니기 때문에 (물론 하도록 할 순 있다.)  
이런 경우에는 메모리 설정에 조심해야 한다.  

