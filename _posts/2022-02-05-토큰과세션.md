---

title: JWT
categories: [인증/인가]
tags: [JWT, 인증/인가]     # TAG names should always be lowercase
author:
  name: Choi Jin Kyu
  link: https://github.com/hmcck27
toc: true
# date: 2022-02-05

img_path: /assets/img/mdImage/

---


# 토큰 vs 세션

앞서 인증을 하는 방법에는 토큰과 세션이 있다고 했다.  

둘의 원리, 차이점, 장단점에 대해서 정리해보자.  

---

## 왜 필요할까 ?

서버와 클라이언트의 통신에는 인증과 인가가 존재한다.  
클라이언트는 인증된 유저여야 하며, 해당 요청에 대한 권한이 존재해야 한다.    

서버-클라이언트 통신에는 주로 **HTTP 프로토콜**을 사용하는데, 이 HTTP 프로토콜은 **stateless**하다.  

stateful하다는 것은 요청을 보낸 클라이언트의 속성을 저장하고 있다는 의미이다.  
반대로 stateless라는 뜻은 기본적으로 http통신에 아무런 조치를 하지 않으면 서버는 누가 요청을 보냈는지 모른다는 의미이다.  

stateless하기 때문에 누가 요청을 보냈는지 별도로 확인 작업을 해줘야 한다.  
그게 인증/인가 작업이 필요하다.  

귀찮게 왜 stateless를 사용하는지는 다음에 http에 대해서 정리하면서 알아가보자.  

이 인증을 관리하는 방식에는 두가지 방식이 있는데,  
그게 바로 **토큰**과 **세션**이다.

---

## 1. 세션기반 인증

세션 기반 인증을 위해서는 session과 cookie가 사용된다.  

session과 cookie는 뭘까 ?  

위에서 우리는 http는 stateless하다고 했다.  
서버와 클라리언트는 한번 연결됬다고 그 연결상태를 저장하지 않는다.  
따라서 http를 보낼때 뭔가 추가적으로 담아서 보내거나 서버에서 그 추가된 무언가를 확인하는 데이터가 없다면,  
서버는 누구의 요청인지 절대로 모를것이다.  

따라서 클라이언트와 서버는 누구인지 확인하기 위해서 별도로 뭔가를 저장하게 되는데,  
클라이언트가 저장하는게 쿠키, 서버가 저장하는게 세션이다.  

세션 기반 인증이 어떻게 진행되는지 flow를 살펴보자.  

1. 유저는 로그인을 시도한다.
2. 서버는 적합한 유저임을 확인하고, {sessionId : 멤버정보} key-value를 세션저장소에 저장한다. 그리고 그 sessionId를 클라이언트에게 반환한다.    
3. 클라이언트(브라우저)는 응답을 받아서 cookie에 sessionId를 저장한다.  
4. 이제 클라이언트는 요청에 sessionId를 cookie에 담아서 보내기 시작한다.
5. 서버는 sessionId를 받고 아까 로그인한 유저임을 확인하고 로그인을 요구하지 않게 된다.  
6. 로그아웃 버튼을 누르게 되면 서버는 sessionId를 삭제한다. 

stateless하기 때문에 별도로 데이터를 저장하고 비교하는 작업을 거치는 것이다.

**세션 기반 인증의 장점**  
1. 클라이언트가 가진 sessionId는 그냥 key값이고, value(회원정보)는 실제로 서버가 들고 있다. 누군가가 sessionId를 알아도 어떤 유저인지 확인하기 어렵기 때문에 보안에 유리하다.
2. 구현 방법이 명확하다. 

**세션 기반 인증의 단점**
1. sessionId를 서버 메모리에 저장해야한다. 모종의 이유로 메모리가 터지거나 하면, 큰일난다.
2. 메모리에 저장되기 때문에 서버를 교체할때 메모리를 잘 교체해야 한다.
3. 서버의 수가 두대 이상으로 늘어나면, 여러 서버가 공유할 수 있는 메모리에 저장해야 한다. -> 세션 클러스터링이라고 한다.  
4. 하나의 유저가 여러 기기로 접속하면 서버에서는 계속해서 재로그인을 요구하게 된다. 유저는 하나인데 sessionID는 기기별로 다르니까.

정리하면, 좋은 방법이지만 이제는 많이 사용하지 않는 방식이다.   
보안이 중요해서 하나의 기기만 접속해야 하는 환경이거나   
유저가 많이 없고 서버의 성능, 서비스의 트래픽 부하가 늘지 않는다면 사용해도 괜찮을것 같다.  
(~~실제로는 이렇게 까지 고려해서 쓰지는 않고 그냥 될것 같으면 쓴다.~~) 반성중이다.

---

## 2. 토큰 기반 인증

위의 세션기반 인증의 단점들은 사실 sessionId를 서버에 저장하기 때문에 발생하는 일이다.  
서버가 아무 정보도 안들고 있으면 다 없어질 문제점들이다.  

토큰은 세션의 이러한 문제점을 해결한다.  
즉 서버는 유저의 정보를 저장하지 않는다.  

토큰을 발행하는 대표적인 방법은 **JWT**이다.  
JWT는 json web token의 줄임말인데 현대 웹서비스의 인증은 대부분 jwt를 통해서 이뤄진다.  

JWT는 복잡하기 때문에 나중에 그 원리에 대해서 정리할 예정이다.  

토큰기반 인증은 다음과 같은 flow로 진행횐다.  

1. 유저는 로그인을 시도한다.
2. 서버는 적합한 유저임을 확인하고 클라이언트에게 토큰을 발급한다.
3. 클라이언트(브라우저)는 받은 토큰을 저장한다.
4. 클라이언트는 매 요청시 발급 받은 토큰을 header에 포함시켜 전송한다.  
5. 서버는 요청이 오면 header의 토큰을 통해 적합한 유저인지 확인하고 권한을 준다.  
6. 앞으로 클라이언트는 매 요청마다 토큰을 통해서 내가 어떤 유저인지 서버에게 알릴 수 있다.

자 여기서 생기는 의문은 서버는 토큰을 보고 어떤 유저인지 어떻게 알까 ?  
토큰은 보통 그냥 아주 긴 랜덤 스트링이다.  

JWT에 대해서 간단한 설명을 하면,  
JWT에는 사용자 정보가 담겨있다.  
물론 암호화된 상태이다.  

그리고 이 토큰이 어떻게 암호화됬는지 그 방식을 보낸다.  
복호화를 위한 키는 서버가 갖고 있다.  
복호화하지 않아도 어떤 유저인지는 알 수 있지만,  
진짜 해당 유저인지 확인하는 건 복호화를 통해서 진행된다.  

**토큰 기반 방식의 장점**
1. 클라이언트만 정보를 갖고 있으니 서버를 늘리거나 교체하거나 해도 부담이 없다.
2. 여러개의 기기로 접속해도 동일한 토큰을 갖게되니 문제가 없다.

**토큰 기반 방식의 단점**
1. 클라이언트가 정보를 들고 있으니 토큰이 손상될 위험이 있다.
2. 서버가 토큰을 어떻게든 처리해줘야 한다.복호화라던가 갱신이라던가 악의적으로 탈취되면 블락한다던가...
3. sessionId보다 길다.

---

## 정리

인증을 구현하는 두가지 방법인 세션과 토큰에 대해서 알아보았다.  
어떤걸 사용할지는 이 서비스에게 어떤 방식이 더 적합할지 개발자가 판단해야 한다.  
판단 기준은 당연히 위에 적은 장단점이다.  

난 둘다 해봤는데, 스프링 시큐리티를 사용하면 세션, 토큰 둘다 편하게 구현이 가능하다.  

하지만 난 토큰을 좀 더 선호한다.  
최근에는 많은 트래픽을 처리하는 문제가 나에게는 중요하기 때문이다.
트래픽 처리 = scaleout, scaleup, msa -> 서버의 분산, 교체가 잦을 수 있다.  
세션을 사용하면 골치 아플수도 있다.  

그럼 끝 !