---

title: Database와 실무
categories: [Database]
tags: [Database]     # TAG names should always be lowercase
author:
name: Choi Jin Kyu
link: https://github.com/hmcck27
toc: true
# date: 2022-02-05

img_path: /assets/img/mdImage/

---

# Database

Database는 아주 중요하다.  
사실 개념적으로 데이터들의 집합이니까 어떤 서비스던 본체는 database라고 생각한다.  
중간 spring같은 application은 단순하게 생각하면 database에 작업 처리를 부탁하는 역할만 한다.  

database의 특징을 한번 정리해보려고 한다.  
뭐 지식 정리라기 보다는 공부하면서 본 개념들이 실무에서 어떻게 느껴지는 감상평처럼 정리하고자 한다.  

참 학교에서 공부할때는 뭔 뜬구름 잡는 소리지 했는데  
실제로 일하다 보면 뼈아프게 다가오는 개념들이 많다.  
학교에서 공부하면서 동시에 예시를 잘 들어줬으면 더 시행착오가 없었을 텐디....

---

## DBMS
Database Management System. 즉 데이터 베이스 관리 시스템이다.  
예를 들어보자. MySql이던 PostgreSql이던 기본적으로 DBMS를 통해서 관리가 가능하다.  
뭐 쿼리를 날리던 데이터 베이스에 어떠한 작업을 할때 기본적으로 그걸 매개해서 적용을 시켜주는 관리 시스템이다.  

---

## RDB
Relational Database. 관계형 데이터 베이스라고 한다.  
정규화된 방식으로 데이터를 저장한다.  
정규화된 방식이라 함은 테이블을 생각하면 된다.  

왜 RDB를 사용할까 ?  
웹 서비스의 대부분은 RDB를 사용한다.  

그 이유는 테이블 형태로 데이터를 저장하고 관리하기 때문에  
즉 정해진 형식이 있기 때문에  
해당 형식만 지키면서 데이터를 관리한다면 관리가 용이해진다.  

개발자가 어떤 방식으로 데이터를 관리할지를 고민하지 않고 RDB의 규칙만 맞춰서 잘 저장하고 관리하면  
대용량 데이터를 저장한다 하더라도 혼동없이 잘 관리가 가능하기 때문이다.  

내 생각에는 RDB를 사용하는 이점은 테이블이다.  
테이블을 컬럼으로 구성되기 때문에 예를 들어서 user table이 있다면,  
우리는 user에 대한 정보를 마구잡이 저장하는게 아니라 무조건적으로 column단위로 생각하게 된다.  

개발자 입장에서도 데이터의 정합성을 고려하게 만드는 구조인것 같다.  

---

## 테이블 연관관계
1. 일대일
2. 일대다
3. 다대다

중요한건 다대다는 사용하지 않는다.  
말로는 다대다라고 하지만 다대다로 직접 테이블을 구성하는 것보다 다대일 일대다 로 중간 매핑 테이블을 두는 방식으로 개발해야 한다.  

---

## 정규화
기존에 존재하던 relation을 분해하는 것을 의미한다.  
정규화를 하는 것의 장점은 구조 확장시 재디자인을 최소화한다는 것이다.    

정규화는 진짜 정말로 중요하다고 생각한다.  
잘못 설계된 그니까 잘 정규화가 안되고 서비스가 릴리즈되고  
기능을 확장할때 이미 굳혀진 구조를 바꾸는 건 너무 어려운 작업이다.  

그럴때마다 아... 처음부터 나눠놓을걸 이라고 후회하는 경우가 너무 많았다.  

---

## ER diagram
중요한것처럼 보이지 않은 수 있다...  
그냥 개발하면 되지 왜 필요하지 ? 라고 생각한다면 오산이다.  

실제로 개발할때는 무조건적으로 ER diagram을 작성해야 한다.  

하지 않으면 나중에 무조건 후회한다.  

서비스가 커지면 테이블들이 어떻게 연관관계를 맺고 있는지 한눈에 안보이는 경우가 많아지고,  
이러면 나중에 쓸데 없이 복잡하게, 혹은 효율성이 떨어지고 데이터를 조회하는 경우가 많아진다.  

그리고 서비스를 이어받아서 개발하게 되는 사람입장에서 ERD가 없으면 정말 난감하다....

---

## Transaction

데이터 베이스에 날라가는 쿼리들의 묶음 단위라고 생각하면 편하다.  
트랜잭션이 반영되야지 실제로 database에 update가 일어난다.  

자 그러면 왜 transaction이 필요할까 ?
transaction이 필요한 것에 의문이 있다면 그건 아직 공부가 덜된거다.  
의문을 가질게 아니라 그냥 쿼리를 실행하는 단위를 지칭하는것이다.  

여러 쿼리를 묶을 수도 있지만 단일 쿼리가 트랜잭션이 담길 수도 있다.  

DBMS 입장에서 보는 쿼리를 담은 구조체라고 생각하면 된다.  

그런데 트랜잭션하면 떠오르는 ACID가 있다.
1. Atomicity  
트랜잭션은 반영되던지, 반영안되던지 둘중 하나라는 의미이다. 트랜잭션에 담긴 쿼리가 10개라면, 이 10개는 항상 같이 움직인다.
2. Consistency  
트랜잭션이 반영되고 나서도 일관성있는 데이터 베이스 상태를 유지해야 한다는 것이다.
3. Isolation  
가장 중요하다. 트랜잭션이 완료되기 전에는 데이터베이스를 참조할 수 없다. 만약에 update치고 있는데 중간에 read하면 대참사가 발생할 거다.
4. Durability  
성공적으로 반영됬다면 이후에 문제가 생겨도 영구적으로 반영되야 한다는 의미이다.  

---

## Index

보통 데이터 베이스에서 특정 row를 찾는 경우는 무지막지하게 빈번하다.  
검색에서 index가 없다면 보통은 테이블 전체를 full scan으로 탐색한다.  
만약에 테이블의 크기가 커진다면 이는 성능을 저하시킨다.  

이런 성능 저하를 막기 위해서 우리는 index를 만든다.  
index는 b-tree 알고리즘을 사용해서 효율적으로 테이블을 검색할 수 있게 해준다. -> 이진 탐색 트리의 효율성을 생각해보자.  

아... 개발할때는 직접 만들일은 많이 없었던것 같다.  
spring data jpa의 구현체로 hibernate를 사용하면 기본적으로 기본키로 인덱스를 만든다.  

물론 기본키를 제외하고 다른 컬럼값으로 데이터를 검색하는 일이 빈번하다면 index를 구성하는것에 대해서 고려해봐야 한다.  

물론 단점도 있다. index는 기법이라던가 그런게 아니다. 실제로 별도의 index 자료구조를 만들어야 하기 때문에  
저장 공간을 소모할뿐더러 C, U, D시 테이블이외애도 index에도 변경사항이 반영되야 한다.  

나같은 경우는 데이터가 많아지고 + 조회하는 컬럼이 한정적이면 index를 만들어보고
효율이 떨어지면 index를 사용하지 않는다.  
