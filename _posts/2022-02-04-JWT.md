---

title: JWT
categories: [인증/인가, JWT]
tags: [JWT, 인증/인가]     # TAG names should always be lowercase
author:
  name: Choi Jin Kyu
  link: https://github.com/hmcck27
toc: true

img_path: /assets/img/mdImage/

---

# JWT (Json Web Token)

늘 개발하면서 인증처리는 JWT를 사용했다.  
JWT의 정체가 뭔지 이번에 한번 정리해보자.  

---

## **JWT가 뭘까 ?**

Json Web Token 말만 이해해보면,

토큰 기반 인증에서 쓰이는 토큰의 종류인데 뭔가 json과 연관이 있는것 같다.  

클라이언트와 서버에서 json 객체를 사용해서 가벼우면서 자가 수용적인 방식으로 데이터를 전송하는것을 말한다.

**자가 수용적**이라는 말은 필요한 정보를 자체적으로 갖고 있다는 말이다.  
필요한 정보란 뭘까 ?  
1. 토큰에 대한 기본 정보
2. 전송되는 데이터. 즉 클라이언트, 서버에서 인증에 사용하는 데이터. (로그인이라면 유저에 대한 데이터)
3. 검증됐다는 것을 증명하는 signature.

2번을 좀더 자세히 보자.

토큰 인증 방식에서는 토큰안에 사용자의 정보가 암호화되서 들어가 있다.
이 암호를 복호화하면 key-value의 형태로 데이터가 저장되있다.
즉 json 형태로 verification용 데이터를 저장하고 
이걸 토큰으로 인코딩 + 암호화해서 서버에서 인증용으로 발급하는 방식이다.  

예를 들면 이런식이다.  
```json
{
  "name" : "jk",
  "address" : "집",
  "status" : "피곤"
}
```
같이 유저에 대한 정보를 담는 json을 해싱과 인코딩을 통해서 토큰으로 만든다.
그러면 eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9  
이런식의 스트링이 만들어지고 이를 토큰으로 사용하게 된다.  

JWT가 현대 웹에서의 인증 표준처럼 쓰여지고 있는데  
왜 그럴까 ?  

---

## **JWT의 특징**

JWT의 특징(장점)들을 알아보자.  
1. **많은 프로그래밍 언어, 프레임워크에서 지원한다.**  
   JWT 같은 경우, 대부분의 주류 프로그래밍 언어에서 지원된다.
2. **http 통신에서 용이하게 전달가능하다.**  
   헤더에 담을 수도. 쿼리 스트링에 파라미터로 담을 수도 있다.  
   헤더에 담는다면 흔히 bearer token을 사용한다.  
   bearer token에 대해서는 다음에 알아보자.  
3. **self-contained하다**.  
   위에서 설명한 것처럼 session과는 다르게 유저에 대한 정보를 서버가 갖고 있지 않고  
   토큰 그 자체가 들고 있다.
4. **다수의 디바이스에서 용이하게 인증이 가능하다.**  
   sessionID가 디바이스가 달라지면서 공유되지 않는 반면에  
   토큰은 그 자체가 데이터를 들고 있기 때문에 다른 기기에서 같은 토큰을 사용할 수 있다.  
5. **다수의 서버에서 용이하게 운영가능하다.**  
   요청이 들어오면 L4 로드밸런서에 의해서 각각의 서버로 요청이 분배되는데, session을 사용한다면  
   각 서버에서 sessionID : user 의 key-pair 데이터가 공유되어야 한다. 
   세션 클러스터링이라고 하는 기술인데 이 기술에다가 추가로 sessionID를 쿠키에 담는다면 CORS문제도 신경써야 한다.
   반면에 토큰은 그 자체에 데이터가 있기 때문에 그런 수고로움을 갖지 않아도 된다.  


---

## **JWT의 사용 시나리오**

내가 JWT를 썻을때는 인증과 인가 처리었다.  
흔히 로그인을 할때 사용하게 되는데, 다음과 같은 시나리오로 JWT가 발급되고 사용된다.  
1. 유저가 로그인을 한다. (signIn api request 보냄.)
2. 서버가 유저의 정보에 기반한 코튼을 발행해서 유저에게 전달한다. (signIn api의 반환)
3. 그 후 유저가 로그인한 상태에서만 사용할 수 있는 기능(마이 페이지, 내 열람 목록, 내 구매 목록, 등등..)을 사용하기 위해
   api 를 사용한다면 request를 보낼때마다 JWT를 http에 담아서 보낸다.
4. 서버는 해당 토큰이 유효한지 검증하고 권한이 있는지 확인해서(인가) api에 response를 보낸다.

---

## **JWT의 구조.**

JWT는 .을 기준으로 3가지 부분으로 나눠어져 있다.

<!-- ![img.png](../assets/img/mdImage/jwt구조.png) -->
![jwt구조](jwt구조.png)  


### **헤더(Header)**

header는 두가지의 정보를 갖고 있다.  

**typ**: 토큰의 타입을 지정한다. JWT이다.  

**alg**: 해싱 알고리즘을 지정한다. 해싱 알고리즘으로는 주로 HMAC SHA256, RSA가 사용되며 이 알고리즘은 토큰을 검증할 때 사용되는 signature에서   
사용된다.

```python
    import json
    import base64

    SECRET_KEY = 'secret_key'

    ## header dictionary 선언
    header = {
        "typ" : "JWT",
        "alg" : "HS256"
    }

    ## header json stringify
    header_json = json.dumps(header, separators=(',',':'))

    ## encode to base64
    encodedHeader = base64.urlsafe_b64encode(header_json.encode())
    encodedHeader = encodedHeader.rstrip(b'=')

    ## print header
    print("encoded header : ",encodedHeader)
```

헤더의 정보를 살펴보면, typ은 당연히 JWT이고, 해싱 알고리즘은 HMAC sha256을 지정해줬다.  
이 json을 stringify해서 문자열로 만든후, base64로 인코딩을 하면, header가 완성된다.  

```text
b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9'
```

* 참고! HMAC sha256과 sha256은 비밀키를 사용하냐 안하냐의 차이다. HMAC이 비밀키를 사용한다.  
* 참고! byte encoding된 문자열에 = 가 존재할 수도 있는데, 이걸 base64의 padding문자라고 부른다.
  이 패딩 문자를 jwt에서는 제거해줘야한다.

### **내용(payload)**

토큰에 담을 정보가 포함된다. 여기에 담은 정보의 한 조각을 **클레임(claim)**이라고 부른다.  
이는 json 처럼 key-value pair의 구조를 가진다.  
토큰에는 여러개의 claim을 넣을 수 있다.  

클레임의 종류는 크게 세가지로 구분된다.

1. 등록된(registered) 클레임
2. 공개(public) 클레임
3. 비공개(private) 클레임

등록된 클레임은 규격으로 등록하는 거라고 보면 되고,  
공개, 비공개는 사용자가 커스텀하게 등록하는 클레임이라고 보면 된다.  

더 자세하게 알아보면,

#### **등록된 클레임**

등록된 클레임은 서비스에서 필요한 정보들이 아닌, 토큰에 대한 정보를 다믹 위해서 이름이 이미 정해진 클레임이다.  
등록된 클레임의 사용은 선택적이다. 하지만 많은 경우 사용할 것을 권장한다.  
간단하게 생각하면 토큰에 대한 메타데이터이다.  

다음과 같은 종류가 있다.  
- iss : 토큰 발급자 (issuer)
- sub : 토큰 제목 (subject) -> 주로 사용자 이메일을 사용하낟.
- aud : 토큰 대상자 (audience)
- exp : 토큰의 만료 시간(expiration), 포멧은 numericDate 형식이어야 하며 언제나 현재보다 이후로 설정되어야 한다.  
- nbf : not before = 토큰의 활성 날짜. 여기도 numericDate 형식이고, 이 날짜가 지나기 전까지는 토큰이 처리되지 않는다.  
- iat : 토큰이 발급된 시간(issued at), 이 값을 사용하여 토큰의 age가 얼마나 되었는지 판단할 수 있다.  
- jti : JWT의 고유 식별자로서, 주로 중복적인 처리를 방지하기 위해 사용된다. 일회용 토큰에 사용하면 유용하다.  

#### **공개 클레임**

사용자 정의 클레임으로 공개된 정보를 위해서 사용된다.  
공개 클레임은 충돌이 방지된(collision-resistant) 이름을 갖고 있어야 한다.  
사용자 정의 클레임이다.  
충돌을 방지하기 위해서는, 클레임 이름을 URI형식으로 짓는다.  
충돌 방지라는 건 공개 클레임간에 같은 이름을 갖는 경우를 말한다.  
따라서 클레임을 이름이 겹치지 않을 만한 이름 URI나 UUID, OID를 사용한다.

```json
{
   "https://hmcck27.github.io" : true,
}
```

#### **비공개 클레임**
등록된 클레임도 아니고, 공개된 클레임들도 아니다. 서버와 클라이언트 간의 협의된 데이터이다.  
여기에 유저의 데이터가 담긴다.

```json
{
   "username": "jk",
   "email" : "hmcck27@gmail.com"
}
```

예제로 payload를 만들어보자.  
```json
{
   "iss" : "hmcck27.github.io",
   "sub" : "token for you",
   "aud" : "jk",
   "exp" : "지금 + 1일",
   "iat" : "지금",
   "https://hmcck27.github.io/jwt_claims/is_jk" : true,
   "username": "jk",
   "email" : "hmcck27@gmail.com"
}
```

코드로 살펴보자.  
위와 같은 payload을 만든다고 가정해보자.  
```python
    import datetime

    ## payload 선언
    payload = {
       "iss" : "hmcck27.github.io",
       "sub" : "token for you",
       "aud" : "jk",
       "exp" :  int((datetime.datetime.now() + datetime.timedelta(days=1)).timestamp()),
       "iat" : int(datetime.datetime.now().timestamp()),
       "https://hmcck27.github.io/jwt_claims/is_jk" : True,
       "username": "jk",
       "email" : "hmcck27@gmail.com"
    }

    ## json stringify
    payload_json = json.dumps(payload, separators=(',', ':'))

    ## base 64 인코딩
    encodedPayload = base64.urlsafe_b64encode(payload_json.encode())
    encodedPayload = encodedPayload.rstrip(b'=')
    print("encoded payload : " , encodedPayload)

```

```text
encoded payload :  b'eyJpc3MiOiJobWNjazI3LmdpdGh1Yi5pbyIsInN1YiI6InRva2VuIGZvciB5b3UiLCJhdWQiOiJqayIsImV4cCI6MTY0Mzk0MTg1MSwiaWF0IjoxNjQzODU1NDUxLCJodHRwczovL2htY2NrMjcuZ2l0aHViLmlvL2p3dF9jbGFpbXMvaXNfamsiOnRydWUsInVzZXJuYW1lIjoiamsiLCJlbWFpbCI6ImhtY2NrMjdAZ21haWwuY29tIn0'
```

다음과 같이 잘 인코딩된다.  

### **signature**

JWT의 마지막 부분은 서명이다.  
이 서명은 header의 인코딩값과 payload의 인코딩값을 합친후 주어진 비밀키로 해쉬를 하여 생성한다.  

header와 payload를 합칠때에는 concatenate의 방식이고, 두 문자열 사이에 . 이 하나가 들어간다.  

위의 예시에서 합쳐진 string은 다음과 같다.  

```text
"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9" + "." + "eyJpc3MiOiJobWNjazI3LmdpdGh1Yi5pbyIsInN1YiI6InRva2VuIGZvciB5b3UiLCJhdWQiOiJqayIsImV4cCI6MTY0Mzk0MTg1MSwiaWF0IjoxNjQzODU1NDUxLCJodHRwczovL2htY2NrMjcuZ2l0aHViLmlvL2p3dF9jbGFpbXMvaXNfamsiOnRydWUsInVzZXJuYW1lIjoiamsiLCJlbWFpbCI6ImhtY2NrMjdAZ21haWwuY29tIn0"

= eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJobWNjazI3LmdpdGh1Yi5pbyIsInN1YiI6InRva2VuIGZvciB5b3UiLCJhdWQiOiJqayIsImV4cCI6MTY0Mzk0MTg1MSwiaWF0IjoxNjQzODU1NDUxLCJodHRwczovL2htY2NrMjcuZ2l0aHViLmlvL2p3dF9jbGFpbXMvaXNfamsiOnRydWUsInVzZXJuYW1lIjoiamsiLCJlbWFpbCI6ImhtY2NrMjdAZ21haWwuY29tIn0
```

이 값을 비밀키로 해싱을 하고 base64로 인코딩한다.

```python
    import hashlib
    import hmac
   
    ## 두 인코딩 string 합치기
    encodedHeaderPayload = encodedHeader + b"." + encodedPayload
   
    ## 비밀키 세팅
    secret_key = "jk_sunfish"
   
    # 해싱 + base64 인코딩
    module = hmac.new(secret_key.encode(), encodedHeaderPayload, hashlib.sha256)
   
    digest = module.digest()
    crypted = base64.urlsafe_b64encode(digest)
    crypted = crypted.rstrip(b"=")
   
    print("crypted : " ,crypted)
   
    print('JWT : ', encodedHeader + b'.' + encodedPayload + b'.' + crypted)
```

출력은 다음과 같다.  

```text
crypted :  b'NBWuqtdxrj2VNBS7xy5Nach30L9Qp4MFYIPijPLinuA'
```

### **JWT 통합**

이 3개의 파트를 합치면 완성된 jwt가 된다.  
한번 합쳐보고, 정말로 잘 토크나이징이 됐는지 검증해보자.

3개를 합친 결과는 이러하다.  

```text
   JWT : b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJobWNjazI3LmdpdGh1Yi5pbyIsInN1YiI6InRva2VuIGZvciB5b3UiLCJhdWQiOiJqayIsImV4cCI6MTY0Mzk1MTAzOCwiaWF0IjoxNjQzODY0NjM4LCJodHRwczovL2htY2NrMjcuZ2l0aHViLmlvL2p3dF9jbGFpbXMvaXNfamsiOnRydWUsInVzZXJuYW1lIjoiamsiLCJlbWFpbCI6ImhtY2NrMjdAZ21haWwuY29tIn0.NBWuqtdxrj2VNBS7xy5Nach30L9Qp4MFYIPijPLinuA'
```

JWT를 잘 만들었는지 확인해보자 !  
https://jwt.io/ 에서 직접 확인해 볼 수 있다.

<!-- ![img.png](../assets/img/mdImage/jwt통합결과.png) -->
![jwt통합결과](jwt통합결과.png)  


잘 만들었다 !

---

## **정리**

직접 JWT를 만들어 봤는데 실제로 이런 과정을 직접 할 일은 없다.  
왜냐하면 대부분의 언어에서 JWT를 지원해주니까.  
그래도 직접 만들어 보는게 더 재밌다..!

아 그리고 url-safe에 대해서 새로 알았는데,  
위의 코드에서 단순히 base64.b64encode()를 사용하지 않았다.  

이 메소드를 사용해서 해보면 제대로 signature가 만들어지지 않는다.  
왜냐하면 url-safe하지 않기 때문이다.  

url에서 예약어처럼 쓰이는 특수문자들이 있는데, url 값 자체에 그러한 특수문자들이 들어가면 안된다.  
그냥 base64인코딩하면 url-safe하지 않아서 +라던가, /라던가의 특수문자들이 그대로 남아있다.  
url-safe하게 하면 이런 특수문자는 - 또는 _으로 교체된다.  

여튼 그렇다 !





